<html>
<head></head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script lang="js">
        async function run(){
            let repeat = true;
            const trainingUrl = 'penguins_train.csv';
            const trainingData = tf.data.csv(trainingUrl, {
                columnConfigs: {
                    species: {
                        isLabel: true
                    },
                    culmen_length_mm: {
                        required: true
                    },
                    culmen_depth_mm: {
                        required: true
                    // },
                    // flipper_length_mm: {
                    //     required: true
                    // },
                    // body_mass_g: {
                    //     required: true
                    }

                    // taken only two features, viz, culmen_length_mm and culmen_depth_mm as they
                    // seggregates the dataset in species in best way as per pairplot
                },
                configuredColumnsOnly: true
            });
            // trainingData.take(1).forEachAsync(e => console.log(e));
            const numOfFeatures = (await trainingData.columnNames()).length - 1;
            // console.log(numOfFeatures);
            // const numOfSamples = 150;
            const convertedTrainingData =
                  trainingData.map(({xs, ys}) => {
                      const labels = [
                            ys.species == "Adelie" ? 1 : 0,
                            ys.species == "Chinstrap" ? 1 : 0,
                            ys.species == "Gentoo" ? 1 : 0
                      ] 
                    //   labels is already an array, Object.values not reqd for it
                      return{ xs: Object.values(xs), ys: labels};
                //   });
                  }).batch(180);
            // convertedData.take(10).forEachAsync(e => console.log(e));
            const testingUrl = 'penguins_test.csv';
            const testingData = tf.data.csv(testingUrl, {
                columnConfigs: {
                    species: {
                        isLabel: true
                    },
                    culmen_length_mm: {
                        required: true
                    },
                    culmen_depth_mm: {
                        required: true
                    // },
                    // flipper_length_mm: {
                    //     required: true
                    // },
                    // body_mass_g: {
                    //     required: true
                    }

                    // taken only two features, viz, culmen_length_mm and culmen_depth_mm as they
                    // seggregates the dataset in species in best way as per pairplot
                },
                configuredColumnsOnly: true
            });
            // trainingData.take(1).forEachAsync(e => console.log(e));
            // const numOfFeatures = (await trainingData.columnNames()).length - 1;
            // console.log(numOfFeatures);
            // const numOfSamples = 150;
            const convertedTestingData =
                  testingData.map(({xs, ys}) => {
                      const labels = [
                            ys.species == "Adelie" ? 1 : 0,
                            ys.species == "Chinstrap" ? 1 : 0,
                            ys.species == "Gentoo" ? 1 : 0
                      ] 
                    //   labels is already an array, Object.values not reqd for it
                      return{ xs: Object.values(xs), ys: labels};
                //   });
                  }).batch(24);
            // convertedTestingData.take(24).forEachAsync(e => console.log(e));
            // const seed = 1; // seed for same results on each run
            const model = tf.sequential();
            model.add(tf.layers.dense({inputShape: [numOfFeatures], 
                                        activation: "relu", 
                                        units: 5, 
                                        // kernelInitializer: tf.initializers.glorotUniform({seed: seed}),
                                        // biasInitializer: tf.initializers.glorotUniform({seed: seed})
                                    }));
            // model.add(tf.layers.dense({activation: "relu", units: 16}))
            // model.add(tf.layers.dense({activation: "relu", units: 8}))
            model.add(tf.layers.dense({activation: "softmax", 
                                        units: 3,
                                        // kernelInitializer: tf.initializers.glorotUniform({seed: seed}),
                                        // biasInitializer: tf.initializers.glorotUniform({seed: seed})
                                    }));
            
            model.compile({loss: "categoricalCrossentropy", optimizer: 'adam', metrics: ['acc']});
            let acc;
            await model.fitDataset(convertedTrainingData, 
                             {epochs: 50,
                                validationData: convertedTestingData,
                              callbacks:[
                                  new tf.CustomCallback({
                                    onEpochEnd: async(epoch, logs) =>{
                                        acc = logs.acc;
                                        console.log("Epoch: " + epoch 
                                                  + " Loss: " + logs.loss.toFixed(4) 
                                                  + " Accuracy: " + logs.acc.toFixed(4) 
                                                  + " Val Loss: " + logs.val_loss.toFixed(4) 
                                                  + " Val Accuracy: " + logs.val_acc.toFixed(4));
                                                },
                                    onTrainEnd: async() =>{
                                        console.log("training done");
                                        if (acc>0.5) {
                                            repeat = false;
                                            console.log(repeat);
                                        }
                                    }
                                }),
                                tf.callbacks.earlyStopping({monitor: 'acc', patience: 5})
                            ]});
            // Test Cases:
            
            // Setosa
            // const testVal = tf.tensor2d([4.4, 2.9, 1.4, 0.2], [1, 4]);
            
            // Versicolor
            // const testVal = tf.tensor2d([6.4, 3.2, 4.5, 1.5], [1, 4]);
            
            // Virginica
            // const testVal = tf.tensor2d([5.8,2.7,5.1,1.9], [1, 4]);
            
            // const prediction = model.predict(testVal);
            // const pIndex = tf.argMax(prediction, axis=1).dataSync();
            
            // const classNames = ["Setosa", "Virginica", "Versicolor"];
            
            // alert(prediction)
            // alert(classNames[pIndex])
            return repeat;
        }
        // Run the function run after the page is loaded.
        // document.addEventListener('DOMContentLoaded', run);
        // run (initialize and train model) for few times using while till desired acc achieved
        let train = true;
        (async ()=>{
            while (train) {
                train = await run();
            }
        })();
        // run();
    </script>
<body>
    <!-- <h1>Simple Tabular Classifier: Iris Flower</h1> -->
</body>
</html>